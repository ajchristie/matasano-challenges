#!/usr/bin/env python2
import random
import hashlib
from set2 import fixedXOR

# for challenge 33: Implement Diffie-Hellman
# parameters:
p = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF
# 1536 bits
g = 2

def mod_exp(base, exp, mod):
    """
    This is equivalent to pow but, in the spirit of the exercise...
    Right-to-left binary method.
    """
    result = 1
    base %= mod
    while exp > 0:
        if (exp % 2) == 1:
            result = (result * base) % mod
        exp /= 2
        base = (base * base) % mod
    return result

def generate_keys(base, modulus):
    """
    Returns a public/private Diffie Hellman key pair given base and modulus parameters.
    Keys are returned as integers.
    """
    private = random.SystemRandom().randint(2, p) # this isn't appropriate, maybe, but for now...
    public = mod_exp(base, private, modulus)
    return public, private

def make_session_key(private, received, modulus):
    """
    Returns Diffie Hellman shared secret given user private key and recieved public key as
    integers.
    """
    return mod_exp(received, private, modulus)

def derive_keys(session_key):
    """
    Given session key (integer), returns a pair of 128-bit keys formatted as hex strings.
    """
    sha = hashlib.sha256()
    sha.update('{:x}'.format(session_key))
    digest = sha.hexdigest()
    return digest[:32], digest[32:]

def derive_key(session_key):
    """
    Like above, but returns a single SHA-1-derived key from the passed (integer) session key.
    """
    sha = hashlib.sha1()
    sha.update('{:x}'.format(session_key))
    return sha.hexdigest()

def DH_handshake():
    print 'A and B generate their respective key pairs:'
    Akeys = generate_keys(g, p)
    print 'A generates: {} (public)'.format(Akeys[0])
    print '             {} (private)'.format(Akeys[1])
    Bkeys = generate_keys(g, p)
    print '\nB generates: {} (public)'.format(Bkeys[0])
    print '             {} (private)'.format(Bkeys[1])

    print 'A and B communicate their public keys to each other and raises to the power of their private keys:'
    Asecret = make_session_key(Akeys[1], Bkeys[0], p)
    Bsecret = make_session_key(Bkeys[1], Akeys[0], p)
    print "A's secret: {}".format(Asecret)
    print "B's secret: {}".format(Bsecret)
    print 'Equal?: ' + str(Asecret == Bsecret)

    print 'A and B derive a session key from this shared secret by hashing. For example:'
    if Asecret == Bsecret:
        print 'Session key: {}'.format(derive_key(Asecret))
    else:
        print "Well, they can't because the secrets don't match. Darn."

# for challenge 34: Implement MITM key fixing
# this is really almost only fun, or enlightening, if you actually do the networking part.
# Later.


# for challange 35: Implement DH group negotiation and break with mailcious 'g'
# like 34, but even more so


# for challange 36: Implement Secure Remote Password
# The following are agreed upon registration with the server (in addition to the DH parameters
# above):
I = 'MrX@gmail.com' # identifier
# v =  # verifier
k = 3 # this thing
s =  random.SystemRandom().randint(1, 65536) # salt

def HMAC(message, key):
    if len(key) > 64:
        key = hashlib.sha256(key).hexdigest()
    elif len(key) < 64:
        key += '\x00'*(64 - len(key))
    inner_pad = fixedXOR(key, '\x36'*64)
    outer_pad = fixedXOR(key, '\x5C'*64)
    return hashlib.sha256(outer_pad + hashlib.sha256(inner_pad + message).hexdigest()).hexdigest()

def generate_random():
    return random.SystemRandom().randint(2, p)

def generate_client_ephemeral(private_exp):
    return mod_exp(g, private_exp, p)

def generate_server_ephemeral(private_exp, v):
    return (k*v + mod_exp(g, private_exp, p)) % p

def generate_client_prekey(passwd, private_exp, server_eph, scrambler):
    h = hashlib.sha256(str(s) + passwd).hexdigest()
    x = int(h, 16)
    return mod_exp(server_eph - k*mod_exp(g, x, p), (private_exp + scrambler*x) % (p - 1), p)

def generate_server_prekey(verifier, private_key, client_eph, scrambler):
    return mod_exp(client_eph * mod_exp(verifier, scrambler, p), private_key, p)

def SRP_authenticate(passwd):
    print 'Despite what it says in the challenge, it seems like the password should never touch the server, so I take the identifier and verifier to have been generated by the client and saved on the server along with the salt, which either the server or the client could have generated. General parameters are agreed upon. Ready to authenticate.\n'
    print 'Begin authentication:'
    print '1. Client -> Server:'
    Aprivate = generate_random()
    Aeph = generate_client_ephemeral(Aprivate)
    print '   I={}, A={}'.format(I, Aeph)

    print '2. Server -> Client:'
    xH = hashlib.sha256(str(s) + passwd).hexdigest() # was actually computed at registration and
    x = int(xH, 16)  # doesn't occur again until step 4. Placed here so that we can access v, which
    v = mod_exp(g, x, p) # was actually computed at registration and stored on server
    Bprivate = generate_random()
    Beph = generate_server_ephemeral(Bprivate, v)
    print '   s={}, B={}'.format(s, Beph)

    print '3. Server and Client compute scrambling value:'
    Hscramble = hashlib.sha256(str(Aeph) + str(Beph)).hexdigest()
    scramble = int(Hscramble, 16)
    print '   uH={}, u={}'.format(Hscramble, scramble)

    print '4. Client computes:'
    # the computations below actually occur here, rather than above
    # xH = hashlib.sha256(str(s) + passwd)
    # x = int(xH, 16)
    client_prekey = generate_client_prekey(passwd, Aprivate, Beph, scramble)
    client_key = hashlib.sha256(str(client_prekey)).hexdigest()
    print '  xH={}, x={}, S={}, K={}'.format(xH, x, client_prekey, client_key)

    print '5. Server computes:'
    server_prekey = generate_server_prekey(v, Bprivate, Aeph, scramble)
    server_key = hashlib.sha256(str(server_prekey)).hexdigest()
    print '   S={}, K={}'.format(server_prekey, server_key)

    print '6. Client -> Server:'
    hm = HMAC(str(s), client_key)
    print '   HMAC-SHA256(K, s) = {}'.format(hm)

    print '7. Server response:'
    server_hm = HMAC(str(s), server_key)
    if server_hm == hm:
        print '   OK'
    else:
        print '   AUTHENTICATION FAILED'


# for challange 37: Break SRP with zero key
# The basic idea here is that if the protocol doesn't include a check on the server to make sure it # hasn't been passed a 0 as ephemeral value, you can get away with not knowing the private random
# value or password because the session key the server will end up calculating is just H(s, 0), and
# s is passed back by the server in step 2 of the protocol w/o requiring any authentication. Easy.


# for challenge 38: Offline dictionary attack on simplified SRP
# Simplified? Pfft.


# for challenge 39: Implement RSA
from Crypto.PublicKey import RSA

def ext_gcd(m, n):
    """
    Return a triple: (gcd(m,n), a, b), where a and b are Bezout coefficients, i.e.,
        am + bn = gcd(m, n)
    """
    if m == 0:
        return (n, 0, 1)
    else:
        g, y, x = ext_gcd(n % m, m)
        return (g, x - (n // m) * y, y)

def modinv(x, mod):
    """
    Returns the inverse of integer x modulo mod, which are assumed to be coprime. This DOES NOT perform safety checks for coprimality. If gcd(x, mod) != 1, this function will return the Bezout coefficient of x in the gcd reduction.
    """
    _, inv, _ = ext_gcd(x, mod)
    return inv % mod

def lcm(m, n):
    return (m * n) / ext_gcd(m, n)[0]

def string_convert(string):
    return int(string.encode('hex'), 16)

def num_convert(num):
    if isinstance(num, long):
        s = hex(num)
        s = '0'*(len(s[2:-1]) % 2) + s[2:-1]
    else:
        s = '0'*(len(hex(num)[2:]) % 2) + hex(num)[2:]
    return s.decode('hex')

def RSA_encrypt(message, key, modulus):
    return mod_exp(message, key, modulus)

def RSA_decrypt(message, key, p, q):
    m1 = mod_exp(message, key % (p-1), p)
    m2 = mod_exp(message, key % (q-1), q)
    qinv = modinv(q, p)
    h = (qinv * (m1 - m2)) % p
    return (m2 + h*q)

def RSA_demo(message): # message should just be a number, and not especially big
    keys = RSA.generate(2048, e=3) # we'll just use the primes and modulus; no cheating
    print 'Generate parameters: p={}'.format(keys.p)
    print '                     q={}'.format(keys.q)
    print '                     N={}'.format(keys.n)
    print '\nPublic key: (e=3, N)'
    d = modinv(3, lcm((keys.p) - 1, (keys.q) - 1))
    print 'Private key: d={}'.format(d)
    print 'Your message: ' + str(message)
    c = RSA_encrypt(message, 3, keys.n)
    ctext = num_convert(c)
    print 'Encrypted: ' + repr(ctext)
    reconverted = string_convert(ctext)
    ptext = RSA_decrypt(reconverted, d, keys.p, keys.q)
    print 'Decrypted: ' + str(ptext)

# for challenge 40: Implement RSA e=3 broadcast attack
# This is just understanding CRT. Which I do.
